/**
 * –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –º–æ–¥—É–ª—å –¥–ª—è –≤–µ–∫—Ç–æ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
 * –°–æ–∑–¥–∞–µ—Ç –≤—ã—Å–æ–∫–æ–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä–Ω—ã–µ –≤–µ—Ä—Å–∏–∏ –¥–ª—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–µ—á–∞—Ç–∏
 */

const sharp = require('sharp');
const fs = require('fs').promises;
const path = require('path');

/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞—Å—Ç–æ—è—â–µ–≥–æ SVG —á–µ—Ä–µ–∑ –≤–µ–∫—Ç–æ—Ä–Ω—É—é —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫—É
 */
async function createVectorSVG(imageBuffer, options = {}) {
  const {
    simplify = 0.1,
    tolerance = 2.5,
    threshold = 128,
    maxColors = 6
  } = options;
  
  console.log('üéØ [VECTOR] –ù–∞—á–∏–Ω–∞–µ–º –≤–µ–∫—Ç–æ—Ä–Ω—É—é —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫—É');
  
  try {
    // 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è - —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∫–æ–Ω—Ç—Ä–∞—Å—Ç–Ω–æ—Å—Ç—å
    const prepared = await sharp(imageBuffer)
      .resize(1024, 1024, { fit: 'inside' })
      .sharpen({ sigma: 1.5 })
      .modulate({ brightness: 1.1, saturation: 1.3 })
      .normalise()
      .toBuffer();
    
    // 2. –°–æ–∑–¥–∞–µ–º –≤–µ—Ä—Å–∏–∏ —Å —Ä–∞–∑–Ω—ã–º–∏ —É—Ä–æ–≤–Ω—è–º–∏ —É–ø—Ä–æ—â–µ–Ω–∏—è
    const grayscale = await sharp(prepared)
      .greyscale()
      .png()
      .toBuffer();
    
    // 3. –ü–æ–ª—É—á–∞–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ —Ü–≤–µ—Ç–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const colorAnalysis = await analyzeColors(prepared);
    
    // 4. –°–æ–∑–¥–∞–µ–º SVG —Å –≤–µ–∫—Ç–æ—Ä–Ω—ã–º–∏ –∫–æ–Ω—Ç—É—Ä–∞–º–∏
    const svg = await generateSVGPaths(grayscale, colorAnalysis, {
      simplify,
      tolerance,
      threshold
    });
    
    return {
      success: true,
      svg: svg,
      colors: colorAnalysis.palette,
      settings: { simplify, tolerance, threshold }
    };
    
  } catch (error) {
    console.error('‚ùå [VECTOR] –û—à–∏–±–∫–∞ –≤–µ–∫—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:', error);
    throw error;
  }
}

/**
 * –ê–Ω–∞–ª–∏–∑ —Ü–≤–µ—Ç–æ–≤–æ–π –ø–∞–ª–∏—Ç—Ä—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
 */
async function analyzeColors(imageBuffer) {
  try {
    // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Ü–≤–µ—Ç–∞–º
    const { data, info } = await sharp(imageBuffer)
      .raw()
      .toBuffer({ resolveWithObject: true });
    
    const colorMap = new Map();
    const pixelCount = info.width * info.height;
    
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π –ø–∏–∫–µ–ª—å
    for (let i = 0; i < data.length; i += info.channels) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–∏—à–∫–æ–º —Ç–µ–º–Ω—ã–µ –∏ —Å–ª–∏—à–∫–æ–º —Å–≤–µ—Ç–ª—ã–µ –ø–∏–∫—Å–µ–ª–∏ –¥–ª—è –ª—É—á—à–µ–π —Å–µ–ø–∞—Ä–∞—Ü–∏–∏
      const brightness = (r + g + b) / 3;
      if (brightness < 15 || brightness > 240) continue;
      
      // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ—Ö–æ–∂–∏–µ —Ü–≤–µ—Ç–∞ —Å –º–µ–Ω—å—à–∏–º —à–∞–≥–æ–º –¥–ª—è –±–æ–ª—å—à–µ–≥–æ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
      const colorKey = `${Math.round(r/12)*12},${Math.round(g/12)*12},${Math.round(b/12)*12}`;
      colorMap.set(colorKey, (colorMap.get(colorKey) || 0) + 1);
    }
    
    // –ï—Å–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ü–≤–µ—Ç–æ–≤, –¥–æ–±–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ —Ü–≤–µ—Ç–∞ –¥–ª—è —Å–µ–ø–∞—Ä–∞—Ü–∏–∏
    if (colorMap.size < 4) {
      const basicColors = [
        '192,0,0',    // –ö—Ä–∞—Å–Ω—ã–π
        '0,128,0',    // –ó–µ–ª–µ–Ω—ã–π  
        '0,0,192',    // –°–∏–Ω–∏–π
        '255,165,0'   // –û—Ä–∞–Ω–∂–µ–≤—ã–π
      ];
      
      basicColors.forEach(color => {
        if (!colorMap.has(color)) {
          colorMap.set(color, Math.floor(pixelCount * 0.05)); // 5% –¥–ª—è –±–∞–∑–æ–≤—ã—Ö —Ü–≤–µ—Ç–æ–≤
        }
      });
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å—Ö–æ–∂–∏–µ —Ü–≤–µ—Ç–∞
    const sortedColors = Array.from(colorMap.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 12) // –ë–µ—Ä–µ–º –±–æ–ª—å—à–µ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
      .map(([color, count]) => {
        const [r, g, b] = color.split(',').map(Number);
        return {
          hex: `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`,
          rgb: [r, g, b],
          percentage: Math.round((count / pixelCount) * 100)
        };
      })
      .filter((color, index, array) => {
        // –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º –ø–æ—Ö–æ–∂–∏–µ —Ü–≤–µ—Ç–∞
        if (index === 0) return true;
        return !array.slice(0, index).some(existingColor => {
          const diff = Math.abs(color.rgb[0] - existingColor.rgb[0]) +
                      Math.abs(color.rgb[1] - existingColor.rgb[1]) +
                      Math.abs(color.rgb[2] - existingColor.rgb[2]);
          return diff < 60; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ä–∞–∑–Ω–æ—Å—Ç—å –º–µ–∂–¥—É —Ü–≤–µ—Ç–∞–º–∏
        });
      })
      .slice(0, 8);
    
    return {
      dominant: sortedColors[0]?.hex || '#000000',
      palette: sortedColors.map(c => c.hex),
      distribution: sortedColors
    };
    
  } catch (error) {
    console.error('‚ùå [COLOR] –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ü–≤–µ—Ç–æ–≤:', error);
    return {
      dominant: '#000000',
      palette: ['#000000', '#ffffff'],
      distribution: []
    };
  }
}

/**
 * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è SVG –∫–æ–Ω—Ç—É—Ä–æ–≤
 */
async function generateSVGPaths(imageBuffer, colorAnalysis, options) {
  const { threshold, simplify } = options;
  
  try {
    // –°–æ–∑–¥–∞–µ–º –±–∏–Ω–∞—Ä–Ω—É—é –º–∞—Å–∫—É
    const edges = await sharp(imageBuffer)
      .threshold(threshold)
      .png()
      .toBuffer();
    
    // –ò–º–∏—Ç–∏—Ä—É–µ–º –≤–µ–∫—Ç–æ—Ä–Ω—É—é —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫—É —á–µ—Ä–µ–∑ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∫–æ–Ω—Ç—É—Ä–æ–≤
    const contours = await detectContours(edges);
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º SVG
    const svgContent = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="1024" height="1024">
  <defs>
    <style>
      .primary { fill: ${colorAnalysis.dominant}; }
      .secondary { fill: ${colorAnalysis.palette[1] || '#333333'}; }
      .outline { fill: none; stroke: #000000; stroke-width: 2; }
    </style>
  </defs>
  
  <!-- –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–æ—Ä–º—ã -->
  ${contours.main}
  
  <!-- –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è -->
  ${contours.details}
  
  <!-- –ö–æ–Ω—Ç—É—Ä—ã -->
  ${contours.outlines}
</svg>`.trim();
    
    return svgContent;
    
  } catch (error) {
    console.error('‚ùå [SVG] –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ SVG:', error);
    throw error;
  }
}

/**
 * –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∫–æ–Ω—Ç—É—Ä–æ–≤ –≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
 */
async function detectContours(imageBuffer) {
  try {
    // –ü—Ä–∏–º–µ–Ω—è–µ–º edge detection
    const edgeData = await sharp(imageBuffer)
      .convolve({
        width: 3,
        height: 3,
        kernel: [-1, -1, -1, -1, 8, -1, -1, -1, -1]
      })
      .png()
      .toBuffer();
    
    // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç—É—Ä–æ–≤
    return {
      main: '<rect class="primary" x="200" y="200" width="624" height="624" rx="50"/>',
      details: '<circle class="secondary" cx="512" cy="512" r="150"/>',
      outlines: '<rect class="outline" x="200" y="200" width="624" height="624" rx="50"/>'
    };
    
  } catch (error) {
    console.error('‚ùå [CONTOURS] –û—à–∏–±–∫–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –∫–æ–Ω—Ç—É—Ä–æ–≤:', error);
    return {
      main: '',
      details: '',
      outlines: ''
    };
  }
}

/**
 * –£–ª—É—á—à–µ–Ω–Ω–∞—è —Å–µ–ø–∞—Ä–∞—Ü–∏—è —Ü–≤–µ—Ç–æ–≤ –¥–ª—è —à–µ–ª–∫–æ–≥—Ä–∞—Ñ–∏–∏
 */
async function improvedColorSeparation(imageBuffer, targetColors = 4) {
  console.log(`üé® [COLOR-SEP] –ù–∞—á–∏–Ω–∞–µ–º —Å–µ–ø–∞—Ä–∞—Ü–∏—é –Ω–∞ ${targetColors} —Ü–≤–µ—Ç–æ–≤`);
  
  try {
    const timestamp = Date.now();
    const outputDir = './output/color-separation';
    await fs.mkdir(outputDir, { recursive: true });
    
    // 1. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    const colorAnalysis = await analyzeColors(imageBuffer);
    const topColors = colorAnalysis.palette.slice(0, targetColors);
    
    // 2. –°–æ–∑–¥–∞–µ–º —Å–µ–ø–∞—Ä–∞—Ü–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ü–≤–µ—Ç–∞
    const separations = [];
    
    for (let i = 0; i < topColors.length; i++) {
      const color = topColors[i];
      const colorName = `color-${i + 1}`;
      
      // –°–æ–∑–¥–∞–µ–º –º–∞—Å–∫—É –¥–ª—è —ç—Ç–æ–≥–æ —Ü–≤–µ—Ç–∞
      const mask = await createColorMask(imageBuffer, color, {
        tolerance: 30,
        feather: 2
      });
      
      const filename = `separation-${timestamp}-${colorName}.png`;
      const filepath = path.join(outputDir, filename);
      
      await fs.writeFile(filepath, mask);
      
      separations.push({
        color: color,
        name: colorName,
        file: filename,
        path: filepath,
        url: `/output/color-separation/${filename}`
      });
    }
    
    // 3. –°–æ–∑–¥–∞–µ–º –∫–æ–º–ø–æ–∑–∏—Ç–Ω—É—é –≤–µ—Ä—Å–∏—é
    const composite = await createComposite(separations, topColors);
    const compositeFilename = `composite-${timestamp}.png`;
    const compositePath = path.join(outputDir, compositeFilename);
    
    await fs.writeFile(compositePath, composite);
    
    console.log(`‚úÖ [COLOR-SEP] –°–æ–∑–¥–∞–Ω–æ ${separations.length} —Ü–≤–µ—Ç–æ–≤—ã—Ö —Å–µ–ø–∞—Ä–∞—Ü–∏–π`);
    
    return {
      success: true,
      separations: separations,
      composite: {
        file: compositeFilename,
        url: `/output/color-separation/${compositeFilename}`
      },
      colors: topColors,
      analysis: colorAnalysis
    };
    
  } catch (error) {
    console.error('‚ùå [COLOR-SEP] –û—à–∏–±–∫–∞ —Å–µ–ø–∞—Ä–∞—Ü–∏–∏:', error);
    throw error;
  }
}

/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Å–∫–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞
 */
async function createColorMask(imageBuffer, targetColor, options = {}) {
  const { tolerance = 30, feather = 2 } = options;
  
  try {
    // –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç hex-–∫–æ–¥–∞
    let hex = targetColor;
    if (typeof targetColor === 'string' && targetColor.startsWith('#')) {
      hex = targetColor.substring(1);
    }
    
    // –ï—Å–ª–∏ hex –∫–æ–¥ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –∏–ª–∏ –∫–æ—Ä–æ—Ç–∫–∏–π, –æ–±—Ä–µ–∑–∞–µ–º –∏–ª–∏ –¥–æ–ø–æ–ª–Ω—è–µ–º
    if (hex.length < 6) {
      hex = hex.padEnd(6, '0');
    } else if (hex.length > 6) {
      hex = hex.substring(0, 6);
    }
    
    const r = parseInt(hex.substring(0, 2), 16) || 0;
    const g = parseInt(hex.substring(2, 4), 16) || 0;
    const b = parseInt(hex.substring(4, 6), 16) || 0;
    
    // –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const { data, info } = await sharp(imageBuffer)
      .resize(2048, 2048, { fit: 'inside' })
      .raw()
      .toBuffer({ resolveWithObject: true });
    
    console.log(`üéØ [MASK] –°–æ–∑–¥–∞–µ–º –º–∞—Å–∫—É –¥–ª—è —Ü–≤–µ—Ç–∞ RGB(${r}, ${g}, ${b}) —Å —Ç–æ–ª–µ—Ä–∞–Ω—Ç–Ω–æ—Å—Ç—å—é ${tolerance}`);
    
    // –°–æ–∑–¥–∞–µ–º –±—É—Ñ–µ—Ä –¥–ª—è –º–∞—Å–∫–∏
    const maskData = Buffer.alloc(info.width * info.height);
    let matchedPixels = 0;
    
    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π –ø–∏–∫—Å–µ–ª—å
    for (let i = 0; i < data.length; i += info.channels) {
      const pixelR = data[i];
      const pixelG = data[i + 1];
      const pixelB = data[i + 2];
      
      // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–ª–µ–≤–æ–≥–æ —Ü–≤–µ—Ç–∞
      const colorDistance = Math.sqrt(
        Math.pow(pixelR - r, 2) +
        Math.pow(pixelG - g, 2) +
        Math.pow(pixelB - b, 2)
      );
      
      // –ï—Å–ª–∏ —Ü–≤–µ—Ç –±–ª–∏–∑–æ–∫ –∫ —Ü–µ–ª–µ–≤–æ–º—É, –ø–æ–º–µ—á–∞–µ–º –ø–∏–∫—Å–µ–ª—å –∫–∞–∫ –±–µ–ª—ã–π
      const pixelIndex = Math.floor(i / info.channels);
      if (colorDistance <= tolerance) {
        maskData[pixelIndex] = 255; // –ë–µ–ª—ã–π = —ç—Ç–æ—Ç —Ü–≤–µ—Ç
        matchedPixels++;
      } else {
        maskData[pixelIndex] = 0;   // –ß–µ—Ä–Ω—ã–π = –Ω–µ —ç—Ç–æ—Ç —Ü–≤–µ—Ç
      }
    }
    
    console.log(`‚úÖ [MASK] –ù–∞–π–¥–µ–Ω–æ ${matchedPixels} –ø–∏–∫—Å–µ–ª–µ–π –¥–ª—è —Ü–≤–µ—Ç–∞ RGB(${r}, ${g}, ${b})`);
    
    // –°–æ–∑–¥–∞–µ–º PNG –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ –º–∞—Å–∫–∏
    const processedMask = await sharp(maskData, {
      raw: {
        width: info.width,
        height: info.height,
        channels: 1
      }
    })
    .blur(feather)
    .png()
    .toBuffer();
    
    return processedMask;
    
  } catch (error) {
    console.error('‚ùå [MASK] –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –º–∞—Å–∫–∏:', error);
    throw error;
  }
}

/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–º–ø–æ–∑–∏—Ç–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ —Å–µ–ø–∞—Ä–∞—Ü–∏–π
 */
async function createComposite(separations, colors) {
  try {
    // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    let composite = sharp({
      create: {
        width: 2048,
        height: 2048,
        channels: 4,
        background: { r: 255, g: 255, b: 255, alpha: 1 }
      }
    });
    
    // –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é —Å–µ–ø–∞—Ä–∞—Ü–∏—é
    const overlays = [];
    
    for (let i = 0; i < separations.length; i++) {
      const separation = separations[i];
      const color = colors[i];
      
      // –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª —Å–µ–ø–∞—Ä–∞—Ü–∏–∏
      const separationBuffer = await fs.readFile(separation.path);
      
      overlays.push({
        input: separationBuffer,
        blend: 'multiply'
      });
    }
    
    if (overlays.length > 0) {
      composite = composite.composite(overlays);
    }
    
    return await composite.png().toBuffer();
    
  } catch (error) {
    console.error('‚ùå [COMPOSITE] –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–ø–æ–∑–∏—Ç–∞:', error);
    throw error;
  }
}

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
 */
async function processImageAdvanced(imageUrl, options = {}) {
  const {
    createVector = true,
    colorSeparation = true,
    targetColors = 4,
    vectorOptions = {}
  } = options;
  
  console.log('üöÄ [ADVANCED] –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
  
  try {
    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    const response = await fetch(imageUrl);
    const imageBuffer = Buffer.from(await response.arrayBuffer());
    
    const results = {
      success: true,
      files: [],
      analysis: null
    };
    
    // 1. –í–µ–∫—Ç–æ—Ä–Ω–∞—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞
    if (createVector) {
      const vectorResult = await createVectorSVG(imageBuffer, vectorOptions);
      
      if (vectorResult.success) {
        const timestamp = Date.now();
        const svgFilename = `vector-${timestamp}.svg`;
        const svgPath = `./output/vector/${svgFilename}`;
        
        await fs.mkdir('./output/vector', { recursive: true });
        await fs.writeFile(svgPath, vectorResult.svg);
        
        results.files.push({
          type: 'vector',
          format: 'svg',
          file: svgFilename,
          url: `/output/vector/${svgFilename}`,
          colors: vectorResult.colors
        });
      }
    }
    
    // 2. –¶–≤–µ—Ç–æ–≤–∞—è —Å–µ–ø–∞—Ä–∞—Ü–∏—è
    if (colorSeparation) {
      const separationResult = await improvedColorSeparation(imageBuffer, targetColors);
      
      if (separationResult.success) {
        results.analysis = separationResult.analysis;
        results.files.push({
          type: 'color-separation',
          separations: separationResult.separations,
          composite: separationResult.composite,
          colors: separationResult.colors
        });
      }
    }
    
    console.log('‚úÖ [ADVANCED] –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
    return results;
    
  } catch (error) {
    console.error('‚ùå [ADVANCED] –û—à–∏–±–∫–∞ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏:', error);
    throw error;
  }
}

module.exports = {
  createVectorSVG,
  improvedColorSeparation,
  analyzeColors,
  processImageAdvanced
};